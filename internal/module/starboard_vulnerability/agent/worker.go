package agent

import (
	"context"

	"github.com/robfig/cron/v3"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v16/internal/module/modagent"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v16/pkg/agentcfg"
	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/client-go/kubernetes"
)

type WorkerHolderInterface interface {
	configChanged(containerScanningConfig *agentcfg.ContainerScanningCF) bool
	stop()
}

type workerHolder struct {
	agentID int64
	config  *configurationToUpdateData
	wg      wait.Group
	cancel  context.CancelFunc
}

func newWorkerHolder(log *zap.Logger, api modagent.Api, kubeClientset kubernetes.Interface, gitlabAgentNamespace string, gitlabAgentServiceAccount string) func(ctx context.Context, cfg *configurationToUpdateData) WorkerHolderInterface {
	return func(ctx context.Context, cfg *configurationToUpdateData) WorkerHolderInterface {
		config := cfg.containerScanningConfig
		holder := &workerHolder{
			agentID: cfg.agentId,
			config:  cfg,
		}

		if config == nil {
			holder.cancel = func() {}
			return holder
		}

		cadence, _ := cron.ParseStandard(config.Cadence)

		var targetNamespaces []string
		if config.VulnerabilityReport != nil {
			targetNamespaces = config.VulnerabilityReport.Namespaces
		}

		scanJob := &scanJob{
			log:                       log,
			api:                       api,
			kubeClientset:             kubeClientset,
			gitlabAgentNamespace:      gitlabAgentNamespace,
			gitlabAgentServiceAccount: gitlabAgentServiceAccount,
			agentID:                   holder.agentID,
			targetNamespaces:          targetNamespaces,
			logParser:                 &logParserImpl{},
			resourceRequirements:      config.ResourceRequirements,
		}

		ctx, holder.cancel = context.WithCancel(ctx)
		w := &schedulerWorker{
			job:     scanJob,
			cadence: cadence,
		}

		holder.wg.StartWithContext(ctx, w.Run)
		return holder
	}
}

func (h *workerHolder) configChanged(containerScanningConfig *agentcfg.ContainerScanningCF) bool {
	return !proto.Equal(h.config.containerScanningConfig, containerScanningConfig)
}

func (h *workerHolder) stop() {
	h.cancel()
	h.wg.Wait()
}
