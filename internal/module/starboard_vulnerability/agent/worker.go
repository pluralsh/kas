package agent

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/starboard/pkg/generated/clientset/versioned"
	"github.com/aquasecurity/starboard/pkg/starboard"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v14/internal/module/modagent"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v14/internal/tool/errz"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v14/internal/tool/logz"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v14/pkg/agentcfg"
	"go.uber.org/zap"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/tools/cache"
)

const resyncPeriod = 5 * time.Minute

type worker struct {
	log     *zap.Logger
	api     modagent.Api
	client  versioned.Interface
	config  *agentcfg.StarboardCF
	agentID int64
}

func (w *worker) Run(ctx context.Context) {
	w.log.Info("starting vulnerability report watcher")
	w.newController(ctx).Run(ctx.Done())
}

func (w *worker) newController(ctx context.Context) cache.Controller {
	_, controller := cache.NewInformer(
		w.vulnerabilityReportListWatch(ctx),
		new(v1alpha1.VulnerabilityReport),
		resyncPeriod,
		cache.ResourceEventHandlerFuncs{AddFunc: w.reportHandler(ctx)},
	)

	return controller
}

// vulnerabilityReportListWatch is a hack to inject v1alpha1.SchemeGroupVersion
// into our rest client so that we can watch custom resources.
func (w *worker) vulnerabilityReportListWatch(ctx context.Context) *cache.ListWatch {
	vulnerabilityReportClient := w.client.AquasecurityV1alpha1().VulnerabilityReports(metav1.NamespaceAll)

	listFunc := func(options metav1.ListOptions) (runtime.Object, error) {
		return vulnerabilityReportClient.List(ctx, options)
	}

	watchFunc := func(options metav1.ListOptions) (watch.Interface, error) {
		return vulnerabilityReportClient.Watch(ctx, options)
	}

	return &cache.ListWatch{
		ListFunc:  listFunc,
		WatchFunc: watchFunc,
	}
}

func (w *worker) reportHandler(ctx context.Context) func(obj interface{}) {
	return func(obj interface{}) {
		vulnerabilityReport, ok := obj.(*v1alpha1.VulnerabilityReport)
		if !ok {
			w.log.Error(fmt.Sprintf("Could not convert received object of type %T into *v1alpha1.VulnerabilityReport", obj))
			return
		}

		logger := w.log.With(
			logz.ReportName(vulnerabilityReport.ObjectMeta.Name),
			logz.UID(vulnerabilityReport.ObjectMeta.UID),
		)

		logger.Info("Processing vulnerability report")
		if !w.matchesConfig(vulnerabilityReport.ObjectMeta.Labels) {
			logger.Debug("Skipping vulnerability report because it does not match configured filters")
			return
		}

		payloads, err := Convert(vulnerabilityReport, w.agentID)
		if err != nil {
			logger.Error("Error processing vulnerability report", logz.Error(err))
			return
		}

		logger.Info("Creating vulnerabilities in GitLab", logz.VulnerabilitiesCount(len(payloads)))
		for _, payload := range payloads {
			if err := w.createVulnerability(ctx, payload); err != nil {
				logger.Error("Failed to create vulnerability", logz.Error(err))
			}
		}

		logger.Info("Finished processing vulnerability report")
	}
}

func (w *worker) matchesConfig(labels map[string]string) bool {
	cfg := w.config.VulnerabilityReport
	if cfg == nil {
		return true
	}

	if match(labels[starboard.LabelResourceNamespace], cfg.Namespaces) {
		return true
	}

	for _, filter := range cfg.Filters {
		if matchResource(labels, filter) {
			return true
		}
	}
	return false
}

func matchResource(labels map[string]string, filter *agentcfg.StarboardFilter) bool {
	return matchGreedy(labels[starboard.LabelResourceNamespace], filter.Namespaces) &&
		matchGreedy(labels[starboard.LabelResourceKind], filter.Kinds) &&
		matchGreedy(labels[starboard.LabelContainerName], filter.Containers) &&
		matchGreedy(labels[starboard.LabelResourceName], filter.Resources)
}

func matchGreedy(have string, want []string) bool {
	if len(want) == 0 {
		return true
	}
	return match(have, want)
}

func match(have string, want []string) bool {
	for _, s := range want {
		if strings.EqualFold(s, have) {
			return true
		}
	}
	return false
}

func (w *worker) createVulnerability(ctx context.Context, payload *Payload) (retError error) {
	resp, err := w.api.MakeGitLabRequest(ctx, "/",
		modagent.WithRequestMethod(http.MethodPut),
		modagent.WithJsonRequestBody(payload),
	)
	if err != nil {
		return fmt.Errorf("error making api request: %w", err)
	}
	defer errz.SafeClose(resp.Body, &retError)

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	return
}
