package agent

import (
	"fmt"
	"net/url"
	"strconv"
	"strings"

	"github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/starboard/pkg/starboard"
	report "gitlab.com/gitlab-org/security-products/analyzers/report/v3"
)

// trivyScannerName is the name for Trivy as it appears on v1alpha1.VulnerabilityReport
const trivyScannerName = "Trivy"

var TrivyScanner = report.ScannerDetails{
	ID:   "starboard_trivy",
	Name: "Trivy (via Starboard Operator)",
	Vendor: report.Vendor{
		Name: "GitLab",
	},
}

func IsSupportedScanner(scannerName string) bool {
	return strings.EqualFold(scannerName, trivyScannerName)
}

// Convert turns a Starboard vulnerability report into a slice of payloads which
// can be sent to the internal vulnerability API
func Convert(vulnReport *v1alpha1.VulnerabilityReport, agentID int64) ([]*Payload, error) {
	reportDetails := vulnReport.Report
	scannerName := reportDetails.Scanner.Name
	if !IsSupportedScanner(scannerName) {
		return nil, fmt.Errorf("could not process report due to unsupported scanner: %s", scannerName)
	}

	vulnerabilities := reportDetails.Vulnerabilities
	payloads := make([]*Payload, len(vulnerabilities))
	for i, vuln := range vulnerabilities {
		payload := convert(vuln)
		payload.Vulnerability.Location = convertLocation(vulnReport, vuln, agentID)
		payload.Scanner.Version = reportDetails.Scanner.Version
		payloads[i] = payload
	}

	return payloads, nil
}

type Payload struct {
	Vulnerability *report.Vulnerability `json:"vulnerability"`
	Scanner       report.ScannerDetails `json:"scanner"`
}

func convert(vuln v1alpha1.Vulnerability) *Payload {
	return &Payload{
		Vulnerability: convertVulnerability(vuln),
		Scanner:       TrivyScanner,
	}
}

func convertVulnerability(vuln v1alpha1.Vulnerability) *report.Vulnerability {
	return &report.Vulnerability{
		Name:        vuln.VulnerabilityID,
		Message:     fmt.Sprintf("%s in %s", vuln.VulnerabilityID, vuln.Resource),
		Description: vuln.Title,
		Solution:    fmt.Sprintf("Upgrade %s from %s to %s", vuln.Resource, vuln.InstalledVersion, vuln.FixedVersion),
		Severity:    convertSeverity(vuln.Severity),
		Confidence:  report.ConfidenceLevelUnknown,
		Identifiers: convertIdentifiers(vuln),
		Links:       convertLinks(vuln),
	}
}

var severityMapping = map[v1alpha1.Severity]report.SeverityLevel{
	v1alpha1.SeverityCritical: report.SeverityLevelCritical,
	v1alpha1.SeverityHigh:     report.SeverityLevelHigh,
	v1alpha1.SeverityMedium:   report.SeverityLevelMedium,
	v1alpha1.SeverityLow:      report.SeverityLevelLow,
	v1alpha1.SeverityNone:     report.SeverityLevelInfo,
	v1alpha1.SeverityUnknown:  report.SeverityLevelUnknown,
}

func convertSeverity(severity v1alpha1.Severity) report.SeverityLevel {
	sev, ok := severityMapping[severity]
	if !ok {
		return report.SeverityLevelUnknown
	}
	return sev
}

func convertLocation(vulnReport *v1alpha1.VulnerabilityReport, vuln v1alpha1.Vulnerability, agentID int64) report.Location {
	r := vulnReport.Report
	return report.Location{
		Dependency: &report.Dependency{
			Package: report.Package{Name: vuln.Resource},
			Version: vuln.InstalledVersion,
		},
		KubernetesResource: convertKubernetesResource(vulnReport.ObjectMeta.Labels, agentID),
		Image: fmt.Sprintf(
			"%s/%s:%s",
			r.Registry.Server,
			r.Artifact.Repository,
			r.Artifact.Tag,
		),
	}
}

func convertKubernetesResource(labels map[string]string, agentID int64) *report.KubernetesResource {
	return &report.KubernetesResource{
		Namespace:     labels[starboard.LabelResourceNamespace],
		Name:          labels[starboard.LabelResourceName],
		ContainerName: labels[starboard.LabelContainerName],
		Kind:          labels[starboard.LabelResourceKind],
		AgentID:       strconv.FormatInt(agentID, 10),
	}
}

func convertIdentifiers(vuln v1alpha1.Vulnerability) []report.Identifier {
	id := vuln.VulnerabilityID
	return []report.Identifier{
		{
			Type:  report.IdentifierTypeCVE,
			Name:  id,
			Value: id,
			URL:   fmt.Sprintf("https://cve.mitre.org/cgi-bin/cvename.cgi?name=%s", url.QueryEscape(id)),
		},
	}
}

func convertLinks(vuln v1alpha1.Vulnerability) []report.Link {
	var links []report.Link // nolint:prealloc
	if vuln.PrimaryLink != "" {
		links = append(links, report.Link{URL: vuln.PrimaryLink})
	}

	for _, l := range vuln.Links {
		links = append(links, report.Link{URL: l})
	}
	return links
}
