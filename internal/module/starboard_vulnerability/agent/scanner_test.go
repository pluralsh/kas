package agent

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"testing"

	"github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/starboard/pkg/kube"
	"github.com/aquasecurity/starboard/pkg/starboard"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v15/internal/module/modagent"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v15/internal/tool/testing/mock_modagent"
	"go.uber.org/zap/zaptest"
	appsv1 "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/utils/pointer"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func TestScan(t *testing.T) {
	ctrl := gomock.NewController(t)
	ctx := context.Background()

	// Reconstructed by hand from `kubectl get -o yaml replicasets`
	workloads := &appsv1.ReplicaSetList{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "List",
		},
		Items: []appsv1.ReplicaSet{
			{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "apps/v1",
					Kind:       "ReplicaSet",
				},
				ObjectMeta: metav1.ObjectMeta{
					UID: "46d48440-547a-4979-be0e-8036854bd8ff",
					Annotations: map[string]string{
						"deployment.kubernetes.io/desired-replicas": "1",
						"deployment.kubernetes.io/max-replicas":     "2",
						"deployment.kubernetes.io/revision":         "1",
					},
					Generation: 1,
					Labels: map[string]string{
						"app": "nginx",
					},
					Name:      "nginx",
					Namespace: "default",
					OwnerReferences: []metav1.OwnerReference{
						{
							APIVersion:         "apps/v1",
							Kind:               "Deployment",
							BlockOwnerDeletion: pointer.Bool(true),
							Controller:         pointer.Bool(true),
							Name:               "nginx",
							UID:                "876252f2-9bf8-41f0-ab8a-0ac92f035e25",
						},
					},
				},
				Status: appsv1.ReplicaSetStatus{
					FullyLabeledReplicas: 1,
					ObservedGeneration:   1,
					Replicas:             1,
				},
				Spec: appsv1.ReplicaSetSpec{
					Replicas: pointer.Int32(1),
					Template: v1.PodTemplateSpec{
						ObjectMeta: metav1.ObjectMeta{
							Labels: map[string]string{
								"app": "nginx",
							},
						},
						Spec: v1.PodSpec{
							Containers: []v1.Container{
								{
									Image:                    "nginx:1.16", // Trivy expands this to index.docker.io/library/nginx
									ImagePullPolicy:          v1.PullAlways,
									Name:                     "nginx",
									TerminationMessagePath:   v1.TerminationMessagePathDefault,
									TerminationMessagePolicy: v1.TerminationMessageReadFile,
								},
							},
							DNSPolicy:                     v1.DNSClusterFirst,
							RestartPolicy:                 v1.RestartPolicyAlways,
							SchedulerName:                 "default-scheduler",
							TerminationGracePeriodSeconds: pointer.Int64(30),
						},
					},
				},
			},
			{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "apps/v1",
					Kind:       "ReplicaSet",
				},
				ObjectMeta: metav1.ObjectMeta{
					UID: "4b28ac96-88d2-49a4-946b-0b0f75bc119c",
					Annotations: map[string]string{
						"deployment.kubernetes.io/desired-replicas": "1",
						"deployment.kubernetes.io/max-replicas":     "2",
						"deployment.kubernetes.io/revision":         "1",
					},
					Generation: 1,
					Labels: map[string]string{
						"app": "ubuntu",
					},
					Name:      "ubuntu",
					Namespace: "default",
					OwnerReferences: []metav1.OwnerReference{
						{
							APIVersion:         "apps/v1",
							Kind:               "Deployment",
							BlockOwnerDeletion: pointer.Bool(true),
							Controller:         pointer.Bool(true),
							Name:               "ubuntu",
							UID:                "322d7a5f-1d69-4e38-923d-42b305490837",
						},
					},
				},
				Status: appsv1.ReplicaSetStatus{
					FullyLabeledReplicas: 1,
					ObservedGeneration:   1,
					Replicas:             1,
				},
				Spec: appsv1.ReplicaSetSpec{
					Replicas: pointer.Int32(1),
					Template: v1.PodTemplateSpec{
						ObjectMeta: metav1.ObjectMeta{
							Labels: map[string]string{
								"app": "ubuntu",
							},
						},
						Spec: v1.PodSpec{
							Containers: []v1.Container{
								{
									Image:                    "ubuntu:18.04", // Trivy expands this to index.docker.io/library/nginx
									ImagePullPolicy:          v1.PullAlways,
									Name:                     "ubuntu",
									TerminationMessagePath:   v1.TerminationMessagePathDefault,
									TerminationMessagePolicy: v1.TerminationMessageReadFile,
								},
							},
							DNSPolicy:                     v1.DNSClusterFirst,
							RestartPolicy:                 v1.RestartPolicyAlways,
							SchedulerName:                 "default-scheduler",
							TerminationGracePeriodSeconds: pointer.Int64(30),
						},
					},
				},
			},
		},
	}

	namespaces := &v1.NamespaceList{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "List",
		},
		Items: []v1.Namespace{
			{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "v1",
					Kind:       "Namespace",
				},
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						"kubernetes.io/metadata.name": "default",
					},
					Name:            "default",
					ResourceVersion: "1",
					UID:             "4331bde7-1e01-4024-b419-41bbab05d352",
				},
				Spec: v1.NamespaceSpec{
					Finalizers: []v1.FinalizerName{v1.FinalizerKubernetes},
				},
			},
		},
	}

	reports := map[string][]v1alpha1.VulnerabilityReport{
		"nginx": {
			{
				ObjectMeta: metav1.ObjectMeta{
					Name: "TestWorker",
					UID:  "a7458351-a1f6-428c-a6d9-5047601da48f",
					Labels: map[string]string{
						starboard.LabelContainerName:     "nginx",
						starboard.LabelResourceKind:      "ReplicaSet",
						starboard.LabelResourceName:      "nginx",
						starboard.LabelResourceNamespace: "default",
					},
				},
				Report: v1alpha1.VulnerabilityReportData{
					Scanner: v1alpha1.Scanner{
						Name:    "Trivy",
						Vendor:  "Aqua Security",
						Version: "0.16.0",
					},
					Registry: v1alpha1.Registry{
						Server: "index.docker.io",
					},
					Artifact: v1alpha1.Artifact{
						Repository: "library/nginx",
						Tag:        "1.16",
					},
					Vulnerabilities: []v1alpha1.Vulnerability{
						{
							VulnerabilityID:  "CVE-2020-27350",
							Resource:         "apt",
							InstalledVersion: "1.8.2",
							FixedVersion:     "1.8.2.2",
							Severity:         "MEDIUM",
							Title:            "apt: integer overflows and underflows while parsing .deb packages",
							PrimaryLink:      "https://avd.aquasec.com/nvd/cve-2020-27350",
						},
						{
							VulnerabilityID:  "CVE-2020-3810",
							Resource:         "apt",
							InstalledVersion: "1.8.2",
							FixedVersion:     "1.8.2.1",
							Severity:         "MEDIUM",
							PrimaryLink:      "https://avd.aquasec.com/nvd/cve-2020-3810",
						},
					},
				},
			},
		},
		"ubuntu": {
			{
				ObjectMeta: metav1.ObjectMeta{
					Name: "TestWorker",
					UID:  "3c1e3981-f2f7-48f5-9924-6bb834cea3a4",
					Labels: map[string]string{
						starboard.LabelContainerName:     "ubuntu",
						starboard.LabelResourceKind:      "ReplicaSet",
						starboard.LabelResourceName:      "ubuntu",
						starboard.LabelResourceNamespace: "default",
					},
				},
				Report: v1alpha1.VulnerabilityReportData{
					Scanner: v1alpha1.Scanner{
						Name:    "Trivy",
						Vendor:  "Aqua Security",
						Version: "0.16.0",
					},
					Registry: v1alpha1.Registry{
						Server: "index.docker.io",
					},
					Artifact: v1alpha1.Artifact{
						Repository: "library/ubuntu",
						Tag:        "18.04",
					},
					Vulnerabilities: []v1alpha1.Vulnerability{
						{
							VulnerabilityID:  "CVE-2020-6820",
							Resource:         "firefox",
							InstalledVersion: "73.0.1",
							FixedVersion:     "74.0.1",
							Severity:         "MEDIUM",
							Title:            "firefox: Under certain conditions, a race condition can cause a use-after-free.",
							PrimaryLink:      "https://avd.aquasec.com/nvd/cve-2020-6820",
						},
						{
							VulnerabilityID:  "CVE-2019-15846",
							Resource:         "exim4",
							InstalledVersion: "4.91.0",
							FixedVersion:     "4.92.2",
							Severity:         "MEDIUM",
							PrimaryLink:      "https://avd.aquasec.com/nvd/cve-2019-15846",
						},
					},
				},
			},
		},
	}

	vulnerabilityReportScanner := NewMockVulnerabilityReportScanner(ctrl)
	vulnerabilityReportScanner.EXPECT().Scan(ctx, gomock.Any()).Times(2).
		DoAndReturn(func(ctx context.Context, obj kube.ObjectRef) ([]v1alpha1.VulnerabilityReport, error) {
			report, ok := reports[obj.Name]
			if !ok {
				t.Fatalf("Scan called on unexpected workload: %s", obj.Name)
			}

			return report, nil
		})

	core := fake.NewClientBuilder().
		WithLists(workloads, namespaces).
		Build()

	api := mock_modagent.NewMockApi(ctrl)
	s := &scanJob{
		vulnerabilityReportScanner: vulnerabilityReportScanner,
		log:                        zaptest.NewLogger(t),
		api:                        api,
		core:                       core,
		agentID:                    5000000000,
	}

	api.EXPECT().MakeGitLabRequest(ctx, "/",
		gomock.Any(),
		gomock.Any(),
	).MinTimes(1).
		DoAndReturn(mockVulnerabilityCreate)

	api.EXPECT().MakeGitLabRequest(ctx, "/scan_result",
		gomock.Any(),
		gomock.Any(),
	).Times(1).
		DoAndReturn(func(ctx context.Context, path string, opts ...modagent.GitLabRequestOption) (*modagent.GitLabResponse, error) {
			uuids, err := getUuidsFromOptions(opts)
			require.NoError(t, err)

			// In reports variable we have defined 2 workloads with 2 vulnerabilities in each, as we want to send single
			// request for all workloads, we need to check if this single request contains all returned vulnerabilities.
			expectedVulnerabiltiyIds := []string{
				"a6bdaec3f4d7844f020a80308aa36c4f8d96fe307cb89122dcb264e042e0f4c0",
				"64bc22136defc1ca0aab6bc57e42f92d7f8582858bf6fe062eb6d3dbae63ca24",
				"1081649584062c52009d9b06e1019a3156f20bc3bd8e02c9ebf3783c2e28520a",
				"352f4a9e80409c185112fbcc7d3e400a4f7b296db8a8ade1780d0aaf68981d7f",
			}

			assert.ElementsMatch(t, expectedVulnerabiltiyIds, uuids)

			return &modagent.GitLabResponse{
				StatusCode: 200,
			}, nil
		})

	var wg wait.Group
	wg.StartWithContext(ctx, s.Run)
	wg.Wait()
}

func TestScanEmptyNamespace(t *testing.T) {
	ctrl := gomock.NewController(t)
	ctx := context.Background()

	namespaces := &v1.NamespaceList{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "List",
		},
		Items: []v1.Namespace{
			{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "v1",
					Kind:       "Namespace",
				},
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						"kubernetes.io/metadata.name": "default",
					},
					Name:            "default",
					ResourceVersion: "1",
					UID:             "4331bde7-1e01-4024-b419-41bbab05d352",
				},
				Spec: v1.NamespaceSpec{
					Finalizers: []v1.FinalizerName{v1.FinalizerKubernetes},
				},
			},
		},
	}

	vulnerabilityReportScanner := NewMockVulnerabilityReportScanner(ctrl)
	vulnerabilityReportScanner.EXPECT().Scan(ctx, gomock.Any()).Times(0)

	core := fake.NewClientBuilder().
		WithLists(namespaces).
		Build()

	api := mock_modagent.NewMockApi(ctrl)
	s := &scanJob{
		vulnerabilityReportScanner: vulnerabilityReportScanner,
		log:                        zaptest.NewLogger(t),
		api:                        api,
		core:                       core,
		agentID:                    5000000000,
	}

	api.EXPECT().MakeGitLabRequest(ctx, "/",
		gomock.Any(),
		gomock.Any(),
	).Times(0)

	api.EXPECT().MakeGitLabRequest(ctx, "/scan_result",
		gomock.Any(),
		gomock.Any(),
	).Times(0)

	var wg wait.Group
	wg.StartWithContext(ctx, s.Run)
	wg.Wait()
}

func TestListObject(t *testing.T) {
	for _, kind := range workloadKinds {
		t.Run(fmt.Sprintf("listObject does not panic with %q as input", kind), func(t *testing.T) {
			listObject(kind)
		})
	}
}

func getUuidsFromOptions(opts []modagent.GitLabRequestOption) ([]string, error) {
	body, err := getBodyFromOptions(opts)
	if err != nil {
		return nil, err
	}

	payload := new(reqBody)
	if err := json.Unmarshal(body, payload); err != nil {
		return nil, err
	}

	return payload.UUIDs, nil
}

func getBodyFromOptions(opts []modagent.GitLabRequestOption) ([]byte, error) {
	config, err := modagent.ApplyRequestOptions(opts)
	if err != nil {
		return nil, err
	}

	return io.ReadAll(config.Body)
}

func mockVulnerabilityCreate(ctx context.Context, path string, opts ...modagent.GitLabRequestOption) (*modagent.GitLabResponse, error) {
	body, err := getBodyFromOptions(opts)
	if err != nil {
		return nil, err
	}

	payload := new(Payload)
	if err = json.Unmarshal(body, payload); err != nil {
		return nil, err
	}

	response := &uuidResponse{
		// Technically not a UUID, but for testing
		// purposes it works as a suitible replacement.
		UUID: payload.Vulnerability.ID(),
	}

	var responseBytes []byte
	responseBytes, err = json.Marshal(response)
	if err != nil {
		return nil, err
	}

	return &modagent.GitLabResponse{
		StatusCode: http.StatusOK,
		Body:       io.NopCloser(bytes.NewReader(responseBytes)),
	}, nil
}
