package agent

import (
	"context"
	"fmt"
	"io/ioutil"
	"strings"
	"testing"

	"github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/starboard/pkg/kube"
	"github.com/aquasecurity/starboard/pkg/starboard"
	"github.com/golang/mock/gomock"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v15/internal/module/modagent"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v15/internal/tool/testing/mock_modagent"
	"go.uber.org/zap/zaptest"
	appsv1 "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/utils/pointer"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func TestScan(t *testing.T) {
	ctrl := gomock.NewController(t)
	ctx := context.Background()

	// Reconstructed by hand from `kubectl get -o yaml replicasets`
	workloads := &appsv1.ReplicaSetList{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "List",
		},
		Items: []appsv1.ReplicaSet{
			{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "apps/v1",
					Kind:       "ReplicaSet",
				},
				ObjectMeta: metav1.ObjectMeta{
					UID: "46d48440-547a-4979-be0e-8036854bd8ff",
					Annotations: map[string]string{
						"deployment.kubernetes.io/desired-replicas": "1",
						"deployment.kubernetes.io/max-replicas":     "2",
						"deployment.kubernetes.io/revision":         "1",
					},
					Generation: 1,
					Labels: map[string]string{
						"app": "nginx",
					},
					Name:      "nginx",
					Namespace: "default",
					OwnerReferences: []metav1.OwnerReference{
						{
							APIVersion:         "apps/v1",
							Kind:               "Deployment",
							BlockOwnerDeletion: pointer.Bool(true),
							Controller:         pointer.Bool(true),
							Name:               "nginx",
							UID:                "876252f2-9bf8-41f0-ab8a-0ac92f035e25",
						},
					},
				},
				Status: appsv1.ReplicaSetStatus{
					FullyLabeledReplicas: 1,
					ObservedGeneration:   1,
					Replicas:             1,
				},
				Spec: appsv1.ReplicaSetSpec{
					Replicas: pointer.Int32(1),
					Template: v1.PodTemplateSpec{
						ObjectMeta: metav1.ObjectMeta{
							Labels: map[string]string{
								"app": "nginx",
							},
						},
						Spec: v1.PodSpec{
							Containers: []v1.Container{
								{
									Image:                    "nginx:1.16", // Trivy expands this to index.docker.io/library/nginx
									ImagePullPolicy:          v1.PullAlways,
									Name:                     "nginx",
									TerminationMessagePath:   v1.TerminationMessagePathDefault,
									TerminationMessagePolicy: v1.TerminationMessageReadFile,
								},
							},
							DNSPolicy:                     v1.DNSClusterFirst,
							RestartPolicy:                 v1.RestartPolicyAlways,
							SchedulerName:                 "default-scheduler",
							TerminationGracePeriodSeconds: pointer.Int64(30),
						},
					},
				},
			},
		},
	}

	namespaces := &v1.NamespaceList{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "List",
		},
		Items: []v1.Namespace{
			{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "v1",
					Kind:       "Namespace",
				},
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						"kubernetes.io/metadata.name": "default",
					},
					Name:            "default",
					ResourceVersion: "1",
					UID:             "4331bde7-1e01-4024-b419-41bbab05d352",
				},
				Spec: v1.NamespaceSpec{
					Finalizers: []v1.FinalizerName{v1.FinalizerKubernetes},
				},
			},
		},
	}

	reports := []v1alpha1.VulnerabilityReport{
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "TestWorker",
				UID:  "a7458351-a1f6-428c-a6d9-5047601da48f",
				Labels: map[string]string{
					starboard.LabelContainerName:     "nginx",
					starboard.LabelResourceKind:      "ReplicaSet",
					starboard.LabelResourceName:      "nginx",
					starboard.LabelResourceNamespace: "default",
				},
			},
			Report: v1alpha1.VulnerabilityReportData{
				Scanner: v1alpha1.Scanner{
					Name:    "Trivy",
					Vendor:  "Aqua Security",
					Version: "0.16.0",
				},
				Registry: v1alpha1.Registry{
					Server: "index.docker.io",
				},
				Artifact: v1alpha1.Artifact{
					Repository: "library/nginx",
					Tag:        "1.16",
				},
				Vulnerabilities: []v1alpha1.Vulnerability{
					{
						VulnerabilityID:  "CVE-2020-27350",
						Resource:         "apt",
						InstalledVersion: "1.8.2",
						FixedVersion:     "1.8.2.2",
						Severity:         "MEDIUM",
						Title:            "apt: integer overflows and underflows while parsing .deb packages",
						PrimaryLink:      "https://avd.aquasec.com/nvd/cve-2020-27350",
					},
					{
						VulnerabilityID:  "CVE-2020-3810",
						Resource:         "apt",
						InstalledVersion: "1.8.2",
						FixedVersion:     "1.8.2.1",
						Severity:         "MEDIUM",
						PrimaryLink:      "https://avd.aquasec.com/nvd/cve-2020-3810",
					},
				},
			},
		},
	}

	vulnerabilityReportScanner := NewMockVulnerabilityReportScanner(ctrl)
	vulnerabilityReportScanner.EXPECT().Scan(ctx, kube.ObjectRef{
		Kind:      kube.Kind("ReplicaSet"),
		Name:      "nginx",
		Namespace: "default",
	}).MinTimes(1).
		DoAndReturn(func(ctx context.Context, obj kube.ObjectRef) ([]v1alpha1.VulnerabilityReport, error) {
			return reports, nil
		})

	core := fake.NewClientBuilder().
		WithLists(workloads, namespaces).
		Build()

	api := mock_modagent.NewMockApi(ctrl)
	s := &scanJob{
		vulnerabilityReportScanner: vulnerabilityReportScanner,
		log:                        zaptest.NewLogger(t),
		api:                        api,
		core:                       core,
		agentID:                    5000000000,
	}

	api.EXPECT().MakeGitLabRequest(ctx, "/",
		gomock.Any(),
		gomock.Any(),
	).MinTimes(1).
		DoAndReturn(func(ctx context.Context, path string, opts ...modagent.GitLabRequestOption) (*modagent.GitLabResponse, error) {
			return &modagent.GitLabResponse{
				StatusCode: 200,
				Body:       ioutil.NopCloser(strings.NewReader(`{"uuid": "ed1da145-ed9c-4d4c-adbf-6b9f8a305745"}`)),
			}, nil
		})

	api.EXPECT().MakeGitLabRequest(ctx, "/scan_result",
		gomock.Any(),
		gomock.Any(),
	).MinTimes(1).
		DoAndReturn(func(ctx context.Context, path string, opts ...modagent.GitLabRequestOption) (*modagent.GitLabResponse, error) {
			return &modagent.GitLabResponse{
				StatusCode: 200,
			}, nil
		})

	var wg wait.Group
	wg.StartWithContext(ctx, s.Run)
	wg.Wait()
}

func TestScanEmptyNamespace(t *testing.T) {
	ctrl := gomock.NewController(t)
	ctx := context.Background()

	namespaces := &v1.NamespaceList{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "List",
		},
		Items: []v1.Namespace{
			{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "v1",
					Kind:       "Namespace",
				},
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						"kubernetes.io/metadata.name": "default",
					},
					Name:            "default",
					ResourceVersion: "1",
					UID:             "4331bde7-1e01-4024-b419-41bbab05d352",
				},
				Spec: v1.NamespaceSpec{
					Finalizers: []v1.FinalizerName{v1.FinalizerKubernetes},
				},
			},
		},
	}

	vulnerabilityReportScanner := NewMockVulnerabilityReportScanner(ctrl)
	vulnerabilityReportScanner.EXPECT().Scan(ctx, gomock.Any()).Times(0)

	core := fake.NewClientBuilder().
		WithLists(namespaces).
		Build()

	api := mock_modagent.NewMockApi(ctrl)
	s := &scanJob{
		vulnerabilityReportScanner: vulnerabilityReportScanner,
		log:                        zaptest.NewLogger(t),
		api:                        api,
		core:                       core,
		agentID:                    5000000000,
	}

	api.EXPECT().MakeGitLabRequest(ctx, "/",
		gomock.Any(),
		gomock.Any(),
	).Times(0)

	api.EXPECT().MakeGitLabRequest(ctx, "/scan_result",
		gomock.Any(),
		gomock.Any(),
	).Times(0)

	var wg wait.Group
	wg.StartWithContext(ctx, s.Run)
	wg.Wait()
}

func TestListObject(t *testing.T) {
	for _, kind := range workloadKinds {
		t.Run(fmt.Sprintf("listObject does not panic with %q as input", kind), func(t *testing.T) {
			listObject(kind)
		})
	}
}
