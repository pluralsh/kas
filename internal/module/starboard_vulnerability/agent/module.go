package agent

import (
	"context"
	"errors"
	"fmt"

	"github.com/robfig/cron/v3"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v15/internal/module/modagent"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v15/internal/module/starboard_vulnerability"
	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v15/pkg/agentcfg"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/proto"
	"k8s.io/apimachinery/pkg/util/wait"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var ErrMissingCadence = errors.New("cadence is a required field")

type module struct {
	log           *zap.Logger
	api           modagent.Api
	kubeClientset client.Client
	kasConn       grpc.ClientConnInterface
	scanner       func() (VulnerabilityReportScanner, error)
	holder        *workerHolder
}

func (m *module) Run(ctx context.Context, repositoryConfig <-chan *agentcfg.AgentConfiguration) error {
	policiesUpdateData := make(chan *configurationToUpdateData)
	policiesHolder := m.newSecurityPoliciesWorkerHolder(ctx, policiesUpdateData)

	defer func() {
		policiesHolder.stop()
		if m.holder != nil {
			m.holder.stop()
		}
	}()

	var securityPoliciesEnabled bool

	for {
		select {
		case config, ok := <-repositoryConfig:
			if !ok {
				return nil
			}

			if !securityPoliciesEnabled {
				data := &configurationToUpdateData{
					agentId:         config.AgentId,
					starboardConfig: config.Starboard,
				}

				m.handleUpdate(ctx, data)
			}
		case data := <-policiesUpdateData:
			if data.starboardConfig == nil {
				m.log.Debug("Starboard config is empty, security policies are disabled")
				securityPoliciesEnabled = false
			} else {
				m.log.Debug("Starboard config is present, security policies are enabled")
				securityPoliciesEnabled = true
				m.handleUpdate(ctx, data)
			}
		}
	}
}

func (m *module) handleUpdate(ctx context.Context, data *configurationToUpdateData) {
	if m.holder != nil {
		if m.holder.configChanged(data.starboardConfig) {
			m.holder.stop()
			m.holder = m.newWorkerHolder(ctx, data)
		}
	} else {
		m.holder = m.newWorkerHolder(ctx, data)
	}
}

func (m *module) newSecurityPoliciesWorkerHolder(ctx context.Context, updater chan<- *configurationToUpdateData) *securityPoliciesWorkerHolder {
	workerHolder := &securityPoliciesWorkerHolder{
		worker: securityPoliciesWorker{
			api:     m.api,
			log:     m.log,
			updater: updater,
		},
	}
	ctx, workerHolder.cancel = context.WithCancel(ctx)
	workerHolder.wg.StartWithContext(ctx, workerHolder.worker.Run)

	return workerHolder

}

func (m *module) newWorkerHolder(ctx context.Context, cfg *configurationToUpdateData) *workerHolder {
	config := cfg.starboardConfig
	holder := &workerHolder{
		agentID: cfg.agentId,
		config:  cfg,
	}

	if config == nil {
		holder.cancel = func() {}
		return holder
	}

	cadence, _ := cron.ParseStandard(config.Cadence)

	var targetNamespaces []string
	if config.VulnerabilityReport != nil {
		targetNamespaces = config.VulnerabilityReport.Namespaces
	}

	scanJob := &scanJob{
		log:              m.log,
		api:              m.api,
		core:             m.kubeClientset,
		scanner:          m.scanner,
		agentID:          holder.agentID,
		targetNamespaces: targetNamespaces,
	}

	ctx, holder.cancel = context.WithCancel(ctx)
	w := &worker{
		job:     scanJob,
		cadence: cadence,
	}

	holder.wg.StartWithContext(ctx, w.Run)
	return holder
}

func (m *module) IsRunnableConfiguration(cfg *agentcfg.AgentConfiguration) bool {
	// starboard_vulnerability module is always enabled as it vulnerability scan could be enforced by security policies
	return true
}

func (m *module) DefaultAndValidateConfiguration(cfg *agentcfg.AgentConfiguration) error {
	if cfg.Starboard == nil {
		return nil
	}

	if cfg.Starboard.Cadence == "" {
		return ErrMissingCadence
	}

	if _, err := cron.ParseStandard(cfg.Starboard.Cadence); err != nil {
		return fmt.Errorf("cadence is invalid: %w", err)
	}

	return nil
}

func (m *module) Name() string {
	return starboard_vulnerability.ModuleName
}

type workerHolder struct {
	agentID int64
	config  *configurationToUpdateData
	wg      wait.Group
	cancel  context.CancelFunc
}

type securityPoliciesWorkerHolder struct {
	worker securityPoliciesWorker
	wg     wait.Group
	cancel context.CancelFunc
}

func (h *securityPoliciesWorkerHolder) stop() {
	h.cancel()
	h.wg.Wait()
}

func (h *workerHolder) configChanged(starboardConfig *agentcfg.StarboardCF) bool {
	return !proto.Equal(h.config.starboardConfig, starboardConfig)
}

func (h *workerHolder) stop() {
	h.cancel()
	h.wg.Wait()
}
